
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>automatminer.pipeline &#8212; automatminer 2019.03.27_beta documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for automatminer.pipeline</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The highest level classes for pipelines.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pformat</span>

<span class="kn">from</span> <span class="nn">automatminer.base</span> <span class="k">import</span> <span class="n">LoggableMixin</span><span class="p">,</span> <span class="n">DFTransformer</span>
<span class="kn">from</span> <span class="nn">automatminer.presets</span> <span class="k">import</span> <span class="n">get_preset_config</span>
<span class="kn">from</span> <span class="nn">automatminer.utils.ml</span> <span class="k">import</span> <span class="n">regression_or_classification</span>
<span class="kn">from</span> <span class="nn">automatminer.utils.pkg</span> <span class="k">import</span> <span class="n">check_fitted</span><span class="p">,</span> <span class="n">set_fitted</span><span class="p">,</span> \
    <span class="n">return_attrs_recursively</span><span class="p">,</span> <span class="n">AutomatminerError</span>


<div class="viewcode-block" id="MatPipe"><a class="viewcode-back" href="../../api/automatminer.pipeline.MatPipe.html#automatminer.MatPipe">[docs]</a><span class="k">class</span> <span class="nc">MatPipe</span><span class="p">(</span><span class="n">DFTransformer</span><span class="p">,</span> <span class="n">LoggableMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Establish an ML pipeline for transforming compositions, structures,</span>
<span class="sd">    bandstructures, and DOS objects into machine-learned properties.</span>

<span class="sd">    The pipeline includes:</span>
<span class="sd">        - featurization</span>
<span class="sd">        - ml-preprocessing</span>
<span class="sd">        - automl model fitting and creation</span>

<span class="sd">    If you are using MatPipe for benchmarking, use the &quot;benchmark&quot; method.</span>

<span class="sd">    If you have some training data and want to use MatPipe for production</span>
<span class="sd">    predictions (e.g., predicting material properties for which you have</span>
<span class="sd">    no data) use &quot;fit&quot; and &quot;predict&quot;.</span>

<span class="sd">    The pipeline is transferrable. So it can be fit on one dataset and used</span>
<span class="sd">    to predict the properties of another. Furthermore, the entire pipeline and</span>
<span class="sd">    all constituent objects can be summarized in text with &quot;digest&quot;.</span>

<span class="sd">    ----------------------------------------------------------------------------</span>
<span class="sd">    Note: This pipeline should function the same regardless of which</span>
<span class="sd">    &quot;component&quot; classes it is made out of. E.g. the steps for each method should</span>
<span class="sd">    remain the same whether using the TPOTAdaptor class as the learner or</span>
<span class="sd">    using an AutoKerasAdaptor class as the learner. To use a preset config,</span>
<span class="sd">    import a config from automatminer.configs and do MatPipe(**config).</span>
<span class="sd">    ----------------------------------------------------------------------------</span>

<span class="sd">    Examples:</span>
<span class="sd">        # A benchmarking experiment, where all property values are known</span>
<span class="sd">        pipe = MatPipe()</span>
<span class="sd">        test_predictions = pipe.benchmark(df, &quot;target_property&quot;)</span>

<span class="sd">        # Creating a pipe with data containing known properties, then predicting</span>
<span class="sd">        # on new materials</span>
<span class="sd">        pipe = MatPipe()</span>
<span class="sd">        pipe.fit(training_df, &quot;target_property&quot;)</span>
<span class="sd">        predictions = pipe.predict(unknown_df, &quot;target_property&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">        logger (Logger, bool): A custom logger object to use for logging.</span>
<span class="sd">            Alternatively, if set to True, the default automatminer logger will</span>
<span class="sd">            be used. If set to False, then no logging will occur.</span>
<span class="sd">        log_level (int): The log level. For example logging.DEBUG or 2.</span>
<span class="sd">        autofeaturizer (AutoFeaturizer): The autofeaturizer object used to</span>
<span class="sd">            automatically decorate the dataframe with descriptors.</span>
<span class="sd">        cleaner (DataCleaner): The data cleaner object used to get a</span>
<span class="sd">            featurized dataframe in ml-ready form.</span>
<span class="sd">        reducer (FeatureReducer): The feature reducer object used to</span>
<span class="sd">            select the best features from a &quot;clean&quot; dataframe.</span>
<span class="sd">        learner (DFMLAdaptor): The auto ml adaptor object used to</span>
<span class="sd">            actually run a auto-ml pipeline on the clean, reduced, featurized</span>
<span class="sd">            dataframe.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        The following attributes are set during fitting. Each has their own set</span>
<span class="sd">        of attributes which defines more specifically how the pipeline works.</span>

<span class="sd">        is_fit (bool): If True, the matpipe is fit. The matpipe should be</span>
<span class="sd">            fit before being used to predict data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autofeaturizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cleaner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">learner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">transformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">autofeaturizer</span><span class="p">,</span> <span class="n">cleaner</span><span class="p">,</span> <span class="n">reducer</span><span class="p">,</span> <span class="n">learner</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">transformers</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">transformers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">AutomatminerError</span><span class="p">(</span><span class="s2">&quot;Please specify all dataframe&quot;</span>
                                        <span class="s2">&quot;transformers (autofeaturizer, learner,&quot;</span>
                                        <span class="s2">&quot;reducer, and cleaner), or none (to use&quot;</span>
                                        <span class="s2">&quot;default).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">config</span> <span class="o">=</span> <span class="n">get_preset_config</span><span class="p">(</span><span class="s2">&quot;production&quot;</span><span class="p">)</span>
                <span class="n">autofeaturizer</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;autofeaturizer&quot;</span><span class="p">]</span>
                <span class="n">cleaner</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;cleaner&quot;</span><span class="p">]</span>
                <span class="n">reducer</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;reducer&quot;</span><span class="p">]</span>
                <span class="n">learner</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s2">&quot;learner&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">log_level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span> <span class="o">=</span> <span class="n">autofeaturizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleaner</span> <span class="o">=</span> <span class="n">cleaner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reducer</span> <span class="o">=</span> <span class="n">reducer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learner</span> <span class="o">=</span> <span class="n">learner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleaner</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reducer</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_fit_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_fit_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_fit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ml_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@set_fitted</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a matpipe to a dataframe. Once fit, can be used to predict out of</span>
<span class="sd">        sample data.</span>

<span class="sd">        The dataframe should contain columns having some materials data:</span>
<span class="sd">            - compositions</span>
<span class="sd">            - structures</span>
<span class="sd">            - bandstructures</span>
<span class="sd">            - density of states</span>
<span class="sd">            - user-defined features</span>

<span class="sd">        Any combination of these data is ok.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): Pipe will be fit to this dataframe.</span>
<span class="sd">            target (str): The column in the dataframe containing the target</span>
<span class="sd">                property of interest</span>

<span class="sd">        Returns:</span>
<span class="sd">            MatPipe (self)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_fit_df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ml_type</span> <span class="o">=</span> <span class="n">regression_or_classification</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Problem type is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml_type</span><span class="p">))</span>

        <span class="c1"># Fit transformers on training data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fitting MatPipe pipeline to data.&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleaner</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;MatPipe successfully fit.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_fit_df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="MatPipe.transform"><a class="viewcode-back" href="../../api/automatminer.pipeline.MatPipe.html#automatminer.MatPipe.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">transform_kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">transform_kwargs</span><span class="p">)</span></div>

    <span class="nd">@check_fitted</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict a target property of a set of materials.</span>

<span class="sd">        The dataframe should have the same target property as the dataframe</span>
<span class="sd">        used for fitting. The dataframe should also have the same materials</span>
<span class="sd">        property types at the dataframe used for fitting (e.g., if you fit a</span>
<span class="sd">        matpipe to a df containing composition, your prediction df should have</span>
<span class="sd">        a column for composition).</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): Pipe will be fit to this dataframe.</span>
<span class="sd">            target (str): The column in the dataframe containing the target</span>
<span class="sd">                property of interest</span>

<span class="sd">        Returns:</span>
<span class="sd">            (pandas.DataFrame): The dataframe with target property predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Beginning MatPipe prediction using fitted pipeline.&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleaner</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reducer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;MatPipe prediction completed.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span>

    <span class="nd">@set_fitted</span>
    <span class="k">def</span> <span class="nf">benchmark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">kfold</span><span class="p">,</span> <span class="n">fold_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the target property is known for all data, perform an ML benchmark</span>
<span class="sd">        using MatPipe. Used for getting an idea of how well AutoML can predict</span>
<span class="sd">        a certain target property.</span>

<span class="sd">        MatPipe benchmarks with a nested cross validation, meaning it makes</span>
<span class="sd">        k validation/test splits, where all model selection is done on the train</span>
<span class="sd">        /validation set (a typical CV). When the model is done validating, it is</span>
<span class="sd">        used to predict the previously unseen test set data. This process is</span>
<span class="sd">        repeated for each of the k folds, which (1) mitigates the benchmark from</span>
<span class="sd">        biasing the model based to the selection of test set and (2) better</span>
<span class="sd">        estimates the generalization error than a single validation/test split.</span>

<span class="sd">        tl;dr: Put in a dataset and kfold scheme for nested CV, get out the</span>
<span class="sd">        predicted test sets.</span>

<span class="sd">        Note: MatPipes after benchmarking have been fit on the last fold, not</span>
<span class="sd">        the entire dataset. To use your entire dataset for prediction, use the</span>
<span class="sd">        MatPipe fit and predict methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pandas.DataFrame): The dataframe for benchmarking. Must contain</span>
<span class="sd">            target (str): The column name to use as the ml target property.</span>
<span class="sd">            kfold (sklearn KFold or StratifiedKFold: The cross validation split</span>
<span class="sd">                object to use for nested cross validation. Used to index the</span>
<span class="sd">                dataframe with .iloc, NOT .loc.</span>
<span class="sd">            fold_subset ([int]): A subset of the folds in kfold to evaluate (by</span>
<span class="sd">                index). For example, to run only the 3rd train/validation/test</span>
<span class="sd">                split of the kfold, set fold_subset = [2]. To use the first and</span>
<span class="sd">                fourth, set fold_subset = [0, 3].</span>
<span class="sd">            cache (bool): If True, pre-featurizes the entire dataframe</span>
<span class="sd">                (including test data!) and caches it before iterating over</span>
<span class="sd">                folds. Do NOT use if you are using fittable featurizers whose</span>
<span class="sd">                feature labels are based on their input! Doing so may &quot;leak&quot;</span>
<span class="sd">                information from the testing set to the training set and will</span>
<span class="sd">                over-represent your benchmark. Enabling this for featurizers</span>
<span class="sd">                which are not fittable is completely safe. Note that your</span>
<span class="sd">                autofeaturizer must have a cache_src defined if allow_caching is</span>
<span class="sd">                enabled (do this either through the AutoFeaturizer class or</span>
<span class="sd">                using the cache_src argument to get_preset_config.</span>

<span class="sd">        Returns:</span>
<span class="sd">            results ([pd.DataFrame]): Dataframes containing each fold&#39;s</span>
<span class="sd">                known targets, as well as their independently predicted targets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cache_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="o">.</span><span class="n">cache_src</span>
        <span class="k">if</span> <span class="n">cache_src</span> <span class="ow">and</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_src</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Cache src </span><span class="si">{}</span><span class="s2"> already found! Ensure this featurized data &quot;</span>
                    <span class="s2">&quot;matches the df being benchmarked.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cache_src</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Running pre-featurization for caching.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cache_src</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AutomatminerError</span><span class="p">(</span>
                <span class="s2">&quot;Caching was enabled in AutoFeaturizer but not in benchmark. &quot;</span>
                <span class="s2">&quot;Either disable caching in AutoFeaturizer or enable it by &quot;</span>
                <span class="s2">&quot;passing cache=True to benchmark.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cache</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cache_src</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AutomatminerError</span><span class="p">(</span>
                <span class="s2">&quot;MatPipe cache is enabled, but no cache_src was defined in &quot;</span>
                <span class="s2">&quot;autofeaturizer. Pass the cache_src argument to AutoFeaturizer &quot;</span>
                <span class="s2">&quot;or use the cache_src get_preset_config powerup.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No caching being used in AutoFeaturizer or &quot;</span>
                              <span class="s2">&quot;benchmark.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fold_subset</span><span class="p">:</span>
            <span class="n">fold_subset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">kfold</span><span class="o">.</span><span class="n">n_splits</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Beginning benchmark.&quot;</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fold</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">test_ix</span> <span class="ow">in</span> <span class="n">kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="n">target</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">fold_subset</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Training on fold index </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fold</span><span class="p">))</span>
                <span class="c1"># Split and identify test set</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">test_ix</span><span class="p">]</span>
                <span class="n">train</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Predicting fold index </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fold</span><span class="p">))</span>
                <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
            <span class="n">fold</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@check_fitted</span>
    <span class="k">def</span> <span class="nf">digest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a text digest (summary) of the fitted pipeline. Similar to the log</span>
<span class="sd">        but contains more detail in a structured format.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The filename.</span>

<span class="sd">        Returns:</span>
<span class="sd">            digeststr (str): The formatted pipeline digest.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">digeststr</span> <span class="o">=</span> <span class="n">pformat</span><span class="p">(</span><span class="n">return_attrs_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">digeststr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">digeststr</span>

    <span class="nd">@check_fitted</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;mat.pipe&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickles and saves a pipeline. Direct pickling will not work as some</span>
<span class="sd">        AutoML backends can&#39;t serialize.</span>

<span class="sd">        Note that the saved object should only be used for prediction, and</span>
<span class="sd">        should not be refit. The automl backend is removed and replaced with</span>
<span class="sd">        the best pipeline, so the other evaluated pipelines may not be saved!</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The filename the pipe should be saved as.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">best_pipeline</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reducer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleaner</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="p">]:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learner</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">temp_backend</span>

<div class="viewcode-block" id="MatPipe.load"><a class="viewcode-back" href="../../api/automatminer.pipeline.MatPipe.html#automatminer.MatPipe.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a matpipe that was saved.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The pickled matpipe object (should have been saved</span>
<span class="sd">                using save).</span>
<span class="sd">            logger (bool or logging.Logger): The logger to use for the loaded</span>
<span class="sd">                matpipe.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pipe (MatPipe): A MatPipe object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">pipe</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">learner</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">reducer</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">cleaner</span><span class="p">,</span>
                    <span class="n">pipe</span><span class="o">.</span><span class="n">autofeaturizer</span><span class="p">]:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>

        <span class="n">pipe</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loaded MatPipe from file </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="n">pipe</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Only use this model to make predictions (do not &quot;</span>
                            <span class="s2">&quot;retrain!). Backend was serialzed as only the top &quot;</span>
                            <span class="s2">&quot;model, not the full automl backend. &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pipe</span></div></div>
</pre></div>

          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Alex Dunn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>